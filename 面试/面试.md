# java

## Reetrantlock是如何实现可重入的

https://blog.csdn.net/weixin_32281549/article/details/112350360

1. 通过cas操作置锁的state字段为1
2. 再次获取state时发现为1，置1失败
3. 置1失败后判断是否是当前线程获取的锁，是的话state+1
4. 释放时state为0时才能彻底释放锁

## ConcurrentHashMap

### 1. 数据结构

### 2. 参数

### 3. 源码

### 4. 扩容流程

### 5. CAS + synchronized

### 6. volatile



## 为什么要从永久代转变为元空间

　	1、字符串存在永久代中，容易出现性能问题和内存溢出。

　　2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。

　　3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

　　4、Oracle 可能会将HotSpot 与 JRockit 合二为一。



## 方法区里面有什么

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717184227883.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNjkyOTQ=,size_16,color_FFFFFF,t_70#pic_center)

1. 类型信息

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717184905120.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNjkyOTQ=,size_16,color_FFFFFF,t_70#pic_center)

2. 域信息

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717185021453.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNjkyOTQ=,size_16,color_FFFFFF,t_70#pic_center)

3. 方法信息

   ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717185135125.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNjkyOTQ=,size_16,color_FFFFFF,t_70#pic_center)





## non-final的类变量和final变量什么时候初始化

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717192728829.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNjkyOTQ=,size_16,color_FFFFFF,t_70#pic_center)





![在这里插入图片描述](https://img-blog.csdnimg.cn/20200717184905120.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNjkyOTQ=,size_16,color_FFFFFF,t_70#pic_center)

## 方法区GC

#### 废弃常量

以回收常量池中的字面量为例，如果一个字符串"abcd"已经加入了常量池，但是并没有任何String对象引用常量池中的 "abcd"常量

> 常量池中其他类(接口)、方法、字段的符号引用也与此类似

回收Java堆中的方式也与此类似

#### 无用的类

判定无用的类条件比较严苛，需要同时满足下列三个条件

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

> 注意这里仅仅是"可以"，而并不是和对象一样，不使用了就必然会回收



## java内存区域

https://github.com/Snailclimb/JavaGuide/blob/3965c02cc0f294b0bd3580df4868d5e396959e2e/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md#22-java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88



## GC ROOT 在哪里

- 所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
- VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。

具体来说：

- 虚拟机栈中引用的对象
- 本地方法栈中 JNI(即一般说的Native方法)引用的对象
- 本地方法区中
  - 类静态属性引用的对象
  - 常量引用的对象



## 标记清除、标记复制、标记整理

https://blog.csdn.net/weixin_38168947/article/details/109066221

##  指针碰撞、空闲列表

https://blog.csdn.net/hyman_c/article/details/103051359

内存规整用指针碰撞、不规整用空闲列表



## 类加载过程

Class类没有公共的构造方法，Class对象是在类加载的时候由**Java虚拟机**以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。一个类被加载到内存并供我们使用需要经历如下三个阶段：

1. **加载**，这是由类加载器（ClassLoader）执行的。通过一个类的全限定名来获取其定义的二进制字节流（Class字节码），将这个字节流所代表的静态存储结构转化为方法去的运行时数据接口，根据字节码在java堆中生成一个代表这个类的java.lang.Class对象。
2. **链接**。在链接阶段将验证Class文件中的字节流包含的信息是否符合当前虚拟机的要求，为静态域分配存储空间并设置类变量的初始值（默认的零值），并且如果必需的话，将常量池中的符号引用转化为直接引用。
3. 链接又分为检查、准备、解析
4. **初始化**。到了此阶段，才真正开始执行类中定义的java程序代码。用于执行该类的静态初始器和静态初始块，如果该类有父类的话，则优先对其父类进行初始化。

## static变量/对象是什么时候生成的

类加载时链接过程中，**为静态域分配存储空间并设置类变量的初始值（默认的零值）**，在初始化时 **执行该类的静态初始器和静态初始块**

**常量在链接的准备过程中就已经赋值了**



## 符号引用和直接引用

- **符号引用**。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。
- **直接引用**。可以理解为一个内存地址，或者一个偏移量。比如**类方法，类变量**的直接引用是指向方法区的**指针**；而**实例方法，实例变量**的直接引用则是从实例的头指针开始算起到这个实例变量位置的**偏移量**
- 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。**如果有了直接引用，那么引用的目标必定已经在内存中存在。**



## 如何获得class对象

1. Class.forName(“类的全限定名”)
2. 实例对象.getClass()
3. 类名.class （类字面常量）









# kafka

## kafka完全指南

https://www.cnblogs.com/sujing/p/10960832.html

### kafka是如何实现高性能的

https://zhuanlan.zhihu.com/p/106033054

1. 多分区

2. 顺序读写磁盘

3. 充分利用page cache（kafka是如何充分利用page cache的）https://blog.csdn.net/gx11251143/article/details/107620259

   1. pageCache是什么 平衡内存与磁盘速度的媒介

   2. kafka是怎么使用pageCache的 kafka写直接写pageCache, 最好读写速度匹配，做到空中接力，否则读磁盘影响线上

   3. pageCache参数 dirty_expire_centisecs 写入磁盘的速度 默认半分钟 pageCache被标记为dirty的话，超过这个时间写入磁盘

      dirty_background_ratio pageCache的总大小占内存空间的百分比，默认10%，超过异步写入磁盘

      dirty_ratio dirty page的总大小占总内存量的比例 默认20%, 超过这个比例，阻塞所有write，强制每个进程将自己的文件写入磁盘

4. 零拷贝（什么是零拷贝）
