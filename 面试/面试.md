# java

## Reetrantlock是如何实现可重入的

https://blog.csdn.net/weixin_32281549/article/details/112350360

1. 通过cas操作置锁的state字段为1
2. 再次获取state时发现为1，置1失败
3. 置1失败后判断是否是当前线程获取的锁，是的话state+1
4. 释放时state为0时才能彻底释放锁

## ConcurrentHashMap

### 1. 数据结构

### 2. 参数

### 3. 源码

### 4. 扩容流程

### 5. CAS + synchronized

### 6. volatile



## 为什么要从永久代转变为元空间

　	1、字符串存在永久代中，容易出现性能问题和内存溢出。

　　2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。

　　3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

　　4、Oracle 可能会将HotSpot 与 JRockit 合二为一。



## java内存区域

https://github.com/Snailclimb/JavaGuide/blob/3965c02cc0f294b0bd3580df4868d5e396959e2e/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md#22-java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88



## GC ROOT 在哪里

- 所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。
- VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。



## 标记清除、标记复制、标记整理

https://blog.csdn.net/weixin_38168947/article/details/109066221

##  指针碰撞、空闲列表

https://blog.csdn.net/hyman_c/article/details/103051359

内存规整用指针碰撞、不规整用空闲列表



# kafka

## kafka完全指南

https://www.cnblogs.com/sujing/p/10960832.html

### kafka是如何实现高性能的

https://zhuanlan.zhihu.com/p/106033054

1. 多分区

2. 顺序读写磁盘

3. 充分利用page cache（kafka是如何充分利用page cache的）https://blog.csdn.net/gx11251143/article/details/107620259

   1. pageCache是什么 平衡内存与磁盘速度的媒介

   2. kafka是怎么使用pageCache的 kafka写直接写pageCache, 最好读写速度匹配，做到空中接力，否则读磁盘影响线上

   3. pageCache参数 dirty_expire_centisecs 写入磁盘的速度 默认半分钟 pageCache被标记为dirty的话，超过这个时间写入磁盘

      dirty_background_ratio pageCache的总大小占内存空间的百分比，默认10%，超过异步写入磁盘

      dirty_ratio dirty page的总大小占总内存量的比例 默认20%, 超过这个比例，阻塞所有write，强制每个进程将自己的文件写入磁盘

4. 零拷贝（什么是零拷贝）
